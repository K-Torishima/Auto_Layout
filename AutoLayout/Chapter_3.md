# UIViewControllerとレイアウトをサポートするクラス

## レイアウトの構造とプロセス

UIViewControllerはMVCモデルにおけるコントローラの役割を補っている
iOSアプリでは基本的に一画面に最低一つのVCが存在する
このVCはモデルとviewの媒介であり、ユーザーインタラクションを受けたり、
ある画面において必要となるモデル操作の指令を出したり、Viewに対してレイアウトを指示したりする
そのためVC自身はモデルのロジックを知りませんし、Viewにおいてどのようにレイアウトが実施されているかは知りません
しかし、コントローラーは媒介的な役割を持つので、そのライフサイクルはレイアウトされるオブジェクトたちに大きな影響を与える
Viewオブジェクト生成、制約計算、レイアウト、さらに画面回転などiOSアプリのレイアウトに関係する多くの要素はこのVCをを介して行われるため、レイアウトを深く知るには、VCの理解が不可欠である

### 表示に関わる階層構造 -スクリーン、ウィンドウ、VC

VCは、viewプロパティとしてついとなるViewを持っている
これは、VCのみによって画面に表示されているわけではない
複数の表示に関わるオブジェクトが、階層構造となることでディスプレイに表示されているのです
iOSアプリのViewはMacアプリと同様に、次のような階層構造になっている

![階層構造](image/3-2.png)

### UIViewにおけるレイアウトのライフサイクル

各VCはついとなるUIViewを持っている
UIViewControllerのライフサイクルを理解するには、UIViewのレイアウトライフサイクルを知る必要がある

- 制約の更新
- フレームの更新
- レンダリング
  
#### 制約の更新

制約が変更されると、レイアウトにおけるコンポーネントの位置関係が変更されるので、その制約を満たすために、再計算がレイアウトエンジンのよって行われる、具体的にはUIViewのupdateConstrains()がよばれ、ボトムアップ（子Viewから親View）に制約の計算が実行される

制約の更新は、以下のような条件で引き起こされる

- 制約のactiveフラグによる有効化および無効化
- 制約の優先度変更
- 制約の追加や削除
- 制約を与えられたViewの階層変更

updateConstraints()をオーバーライドすることで、制約が更新するタイミングで独自の処理をつかすることができる
しかしこのメソッドがオーバーライドする必要がない
制約の変更が必要になるのは端末の回転やウインドウサイズの変更、オブジェクトの追加削除といったイベントが発生するタイミングであることが多いからである。
従って、そのイベントの記述に近い場所に制約の変更を記述した方が良いのは、制約更新において、パフォーマンスが十分でない場合がある
このメソッド内で制約を更新すると、レイアウトエンジンが複数の制約変更を特定のレイアウトパス中でバッチ処理できるため、制約を効率よく更新できる

開発者が制約の更新を明示的に実行することも可能、
updateConstrains()を直接呼ぶことはない。
代わりに、updateConstrainsIfNeeded()を呼ぶ

``` swift
self.updateConstraintsIfNeeded()
```

また、SetNeedsUpdateConstraints()
メソッドを呼ぶことでも、制約の更新ができる

このメソッドを呼ぶと、「制約を更新する必要がある」というフラグが立ち、
次のレイアウトパスで制約の再設計が実行される

updateConstraintsIfNeeded()とは違い、即座にupdateConstraints()が呼ばれるだけでなく、複数の箇所で制約を更新しても同じレイアウトパスで制約が更新されるため、少しパフォーマンスが良いのが特徴である

この辺もいろいろやりながら、覚えていくと良さそう

### フレームの更新

制約情報が更新されると、レイアウトを更新するために、レイアウトエンジンが計算した、フレーム情報をViewが受け取りLayoutSubViews()が呼ばれ、トップダウン
にフレームの更新が実施され、更新が必要であれば、制約も更新される
このフレームの更新を引き起こす条件の例として、次の物があげられる

- Viewのフレームが変更された時（端末が回転した時）
- サブビューが追加あるいは、削除された時
- UIScrollViewのサブクラスにおいて、contentOffSetが変更された時

レイアウトが必要なタイミングで、開発者が明示的にフレームの更新を実施することもできる

UIKitによるレイアウトは、スレットセーフではないため、メインスレッドでレイアウトメソッドを呼ぶ必要がある
このフレームの更新を実行するメソッド達は、制約の更新を実行するメソッドと比べるとよく使われる
LayoutSubViewsのオーバーライド

レイアウトの変更はlayoutSubViews()で実行されるため、このメソッドをオーバーライドすることで、制約付与によるレイアウトは難しいレイアウトでも実現できる
オーバーライドした際に、super.layoutSubViews()を実行する時点ですでに制約は更新される、
そのレイアウト情報を用いて処理を実行したい場合に有効
layoutSubViews()は、通常のレイアウトパスで、updateConstrains()と共に、バッチ処理的にレイアウトの変更を行うので、メインスレッドをブロックせずに、レイアウトの変更が実施できる

### レンダリング

レイアウトライフサイクルの３つ目のステップは、更新されたフレーム情報のレンダリング
フレーム情報が更新されたあと、ディスプレイに変更を表示するために、drawRect()メソッドが呼ばれる

iOSにおいては、drawRect()がそれぞれのViewを一度だけオフスクリーンバッファに描画する、描画されたレイヤーは、それぞれ独立した矩形となる
明示的にフラグを立てない限り、単純なオブジェクトの移動や、拡大縮小では再描画されない

再描画が必要な矩形は、drawRect()がグラフィックコンテクストを引数として、受け取り、描写処理を実行する
タイミングはAppleのiOS描画及び、印刷ガイドによると次の条件となる

- Viewの一部を隠している別のViewの移動または除去
- Hidden(非表示)になっていたViewの再表示（プロパティをNOに設定）
- Viewを画面外までスクロールし、際画面内に戻す
- ViewのSeetNeedDisplayメソッドまたはsetNeedsDisplayInRect()メソッドの明示的な呼び出し

drawRect()を直接呼び出すことはなく、setNeedDisplay()またはsetNeedsDisplayInRect()を呼び出すことで
再描画のトリガを与え実行する

タイマーを用いて一秒間に複数回レンダリングすることで、アニメーションにすることもできる

## ViewControllerのライフサイクル

![ライフサイクル](image/3-5.png)

詳細
VCが生成され画面に表示される段階になると、Viewの読み込みが始まる
Viewの呼び込みはloadView()で行われ、完了するとviewdidLoad()が呼ばれる、
次にVCは表示を開始し、viewWillAppear()を飛び出す
その後、レイアウトを実施しるviewWillLayoutSubViews()
が呼ばれることで、フレームの更新が、実施された後にviewDidLayoutSubViews()が呼ばれ、レイアウトが完了したことを通知する
最後にviewDidLayoutSubView()が呼ばれ、レイアウトが完了したことを通知する
最後にレイアウトされたviewが表示されるとviewDidAppear()が呼ばれて画面への表示が完了する

画面遷移をしたり、アプリを閉じたり、した時に呼ばれるのが、VCの非表示プロセス
VCが画面から消える直前にviewWillDisAppear()が呼ばれ、画面遷移が完了してVCがスクリーン常に表示されなくなった時、
viewDidDisapperが呼ばれる
